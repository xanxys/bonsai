syntax="proto3";
package api;

// One chunk server contains several chunks which might be running or stopped.
// Chunks can span multiple worlds, and also can run in isolated mode.
//
// But for now, there's only one chunk.
service ChunkService {
    // New RPC to return CPU/memory/network load of this chunk server? Also need
    // connectivity info. (IMO it makes sense to make FE manage list of chunk
    // servers, and each chunk server don't know about list other than
    // neighbors)
    //
    // (FE will decide whether to spawn new chunk servers, migrate chunks etc).
    // Or maybe just dump them to datastore (because bigtable is expensive to
    // maintain), and make FE query them. With this approach, we get history for
    // free. (we can also do dashboards w/ bigquery)

    // Should be renamed.
    // Get status of chunks.
    rpc Status(StatusQ) returns (StatusS);

    // Return enough information for caller to balance chunks / reach taget state.
    rpc ChunkSummary(ChunkSummaryQ) returns (ChunkSummaryS);

    // Return synchronized snapshot at arbitrary timestamp.
    rpc Snapshot(SnapshotQ) returns (SnapshotS);

    rpc SpawnChunk(SpawnChunkQ) returns (SpawnChunkS);

    // Move some chunks to other chunk server?
    // rpc MigrateChunk()
}

// Spawn a chunk in this chunk server. This request itself is very lightweight.
// (although server might slowdown afterwards).
message SpawnChunkQ {
    ChunkTopology topology = 2;

    // In initialization cycle, num_soil, and then num_water grains are
    // emitted from (0.5, 0.5, 2).
    int32 num_soil = 3;
    int32 num_water = 4;

    reserved 1;
}

message SpawnChunkS {
}

message StatusQ {
}

message StatusS {
    reserved 1, 2;
}

message ChunkSummaryQ {
}

message ChunkSummaryS {
    repeated ChunkTopology chunks = 1;
}


message SnapshotQ {
    repeated string chunk_id = 1;
}

message SnapshotS {
    map<string, ChunkSnapshot> snapshot = 1;
    uint64 timestamp = 2;
}

message ChunkTopology {
    // Opaque unique id of this chunk. Caller will make sure this is actually
    // unique across all biospheres.
    string chunk_id = 1;

    // Description of a neighbor chunk.
    // (dx, dy) != (0, 0) must hold.
    message ChunkNeighbor {
        // Neighbor's chunk id.
        string chunk_id = 1;

        // If true, neighbor is on the same node.
        bool internal = 2;

        // Chunk server IP address where neighbor is running.
        // Disregarded when internal is true.
        string address = 3;

        // Relative position of this neighbor to the newly created chunk.
        // must be relatively small (|dx| <= 1) for correct operation.
        int32 dx = 4;

        // Relative position of this neighbor to the newly created chunk.
        // must be relatively small (|dx| <= 1) for correct operation.
        int32 dy = 5;
    }

    // 8-Neighbors. When not specified, it is assumed that location is empty
    // (regardless of dx, dy) and there is wall between neighbor and this (when
    // neighbor is a 4-neighbor).
    repeated ChunkNeighbor neighbors = 2;
}


// Snapshot of a chunk at given timestamp.
// This contains enough and just enough information for reconstructing it on
// memory.
// Do not include optimization structures in this, since we don't want to break
// compatibility every time we optimize implemenetation.
//
// Serialization acts as validation of internal state.
//
// Coordinates are stored by chunk-local coordinates.
message ChunkSnapshot {
    // Should be negative for normal gravity.
    int32 gravity_z = 1;

    repeated Grain grains = 4;

    reserved 2, 3;
}

// Next Id: 6
message Grain {
    uint64 id = 3;

    CkPosition pos = 1;
    CkVelocity vel = 4;
    enum Kind {
        UNKNOWN = 0;
        WATER = 1;
        SOIL = 2;
        CELL = 3;
    }
    Kind kind = 2;

    // Available iff kind == CELL.
    CellProp cell = 5;
}

// Self-replicating blackbox. Cell has fuzzy sphere-like shape and emits/absorbs
// other grains. Cell doesn't have rotation or angular velocity.
//
// Mass is 1 (base) +
// Next ID: 7
message CellProp {
    // A qual is modeled after proteins.
    // Quals can only exist in Cells, and type of a qual is completely
    // determined by a string of non-empty lowercase alphabet. (e.g. "a", "zsx")
    //
    // Certain quals has effect on cell division and interaction with environment.
    // (TBD)
    //
    // quals stores counts of each qual in this cell. 0 quals must not be serialized.
    // Total count must be <= 32.
    //
    // Mass of quals is 0.
    //
    // Optical property is determined by hash of quals.
    //
    // Intrinsic quals:
    // * zq: Light -> energy converter (chloroplast)
    // * zw: Increase affinity with WATER
    // * zs: Increase affinity with SOIL
    // * zc: Increase affinity with CELL
    map<string, int32> quals = 4;

    // Mass of genome is 0.
    message Gene {
        // activation_count += int(Product(1-0.5^#matches_i)_i * 1000.0)
        repeated string activator = 1;
        // Non-empty quals.
        repeated string products = 2;

        // When this become >= 1000, produces are produced and count is
        // reset to 0.
        uint32 activation_count = 3;
    }
    repeated Gene genome = 5;

    // Division cycle.
    // N: neutral
    // D: dividing
    // N -> D is triggered by presence of: "zd"
    // D -> N: happens automatically as division_count increases.
    message Cycle {
        bool is_dividing = 1;
        // Only present when is_dividing.
        int32 division_count = 2;
    }
    Cycle cycle = 3;

    reserved 1, 2;
}

// Unit: meter
message CkPosition {
    float x = 1;
    float y = 2;
    float z = 3;
}

// Unit: meter/sec
message CkVelocity {
    float x = 1;
    float y = 2;
    float z = 3;
}
