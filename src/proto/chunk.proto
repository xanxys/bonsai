syntax="proto3";
// Proto that can be only used in frontend and chunk server.
// Since detail of physics should be known to client / fe, this file
// should only contain implementation details.
package api;
import "proto/common.proto";

// One chunk server contains several chunks which might be running or stopped.
// Chunks can span multiple worlds, and also can run in isolated mode.
//
// But for now, there's only one chunk.
service ChunkService {
    // New RPC to return CPU/memory/network load of this chunk server? Also need
    // connectivity info. (IMO it makes sense to make FE manage list of chunk
    // servers, and each chunk server don't know about list other than
    // neighbors)
    //
    // (FE will decide whether to spawn new chunk servers, migrate chunks etc).
    // Or maybe just dump them to datastore (because bigtable is expensive to
    // maintain), and make FE query them. With this approach, we get history for
    // free. (we can also do dashboards w/ bigquery)

    // Should be renamed.
    // Get status of chunks.
    rpc Status(StatusQ) returns (StatusS);

    // Return enough information for caller to balance chunks / reach taget state.
    rpc ChunkSummary(ChunkSummaryQ) returns (ChunkSummaryS);

    // Return synchronized snapshot at arbitrary timestamp.
    rpc Snapshot(SnapshotQ) returns (SnapshotS);

    rpc SpawnChunk(SpawnChunkQ) returns (SpawnChunkS);

    // Delete chunks in the server.
    rpc DeleteChunk(DeleteChunkQ) returns (DeleteChunkS);
}

// Spawn a chunk in this chunk server. This request itself is very lightweight.
// (although server might slowdown afterwards).
// Next ID: 7
message SpawnChunkQ {
    ChunkTopology topology = 2;

    // In initialization cycle, num_soil, and then num_water grains are
    // emitted from (0.5, 0.5, 2).
    int32 num_soil = 3;
    int32 num_water = 4;

    // Store snapshot when timestamp % snapshot_modulo == 0.
    // Does nothing when snapshot_modulo <= 0.
    int32 snapshot_modulo = 5;

    // When 0, create an empty chunk.
    // When >0, read from PersistentChunkSnapshot in datastore.
    // In both case, the chunk server will delete snaphots that have
    // (> start_timestamp && same chunk id).
    // If chunk server cannot find specified snapshot, SpawnChunk will silently fail.
    uint64 start_timestamp = 6;

    bool init_from_snapshot = 7;

    reserved 1;
}

message SpawnChunkS {
}

message DeleteChunkQ {
    repeated string chunk_id = 1;
}

message DeleteChunkS {
}

message StatusQ {
}

message StatusS {
    reserved 1, 2;
}

message ChunkSummaryQ {
}

message ChunkSummaryS {
    repeated ChunkTopology chunks = 1;
}


message SnapshotQ {
    repeated string chunk_id = 1;
}

message SnapshotS {
    map<string, ChunkSnapshot> snapshot = 1;
    uint64 timestamp = 2;
}

message ChunkTopology {
    // Opaque unique id of this chunk. Caller will make sure this is actually
    // unique across all biospheres.
    string chunk_id = 1;

    // Description of a neighbor chunk.
    // (dx, dy) != (0, 0) must hold.
    message ChunkNeighbor {
        // Neighbor's chunk id.
        string chunk_id = 1;

        // If true, neighbor is on the same node.
        bool internal = 2;

        // Chunk server IP address where neighbor is running.
        // Disregarded when internal is true.
        string address = 3;

        // Relative position of this neighbor to the newly created chunk.
        // must be relatively small (|dx| <= 1) for correct operation.
        int32 dx = 4;

        // Relative position of this neighbor to the newly created chunk.
        // must be relatively small (|dx| <= 1) for correct operation.
        int32 dy = 5;
    }

    // 8-Neighbors. When not specified, it is assumed that location is empty
    // (regardless of dx, dy) and there is wall between neighbor and this (when
    // neighbor is a 4-neighbor).
    repeated ChunkNeighbor neighbors = 2;
}


// Snapshot of a chunk at given timestamp.
// This contains enough and just enough information for reconstructing it on
// memory.
// Do not include optimization structures in this, since we don't want to break
// compatibility every time we optimize implemenetation.
//
// Serialization acts as validation of internal state.
//
// Coordinates are stored by chunk-local coordinates.
message ChunkSnapshot {
    // Should be negative for normal gravity.
    int32 gravity_z = 1;

    repeated Grain grains = 4;

    reserved 2, 3;
}

// Next Id: 6
message Grain {
    uint64 id = 3;

    CkPosition pos = 1;
    CkVelocity vel = 4;
    enum Kind {
        UNKNOWN = 0;
        WATER = 1;
        SOIL = 2;
        CELL = 3;
    }
    Kind kind = 2;

    // Available iff kind == CELL.
    CellProp cell_prop = 5;
}


// Unit: meter
message CkPosition {
    float x = 1;
    float y = 2;
    float z = 3;
}

// Unit: meter/sec
message CkVelocity {
    float x = 1;
    float y = 2;
    float z = 3;
}
