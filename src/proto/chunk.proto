syntax="proto3";
package api;

// One chunk server contains several chunks which might be running or stopped.
// Chunks can span multiple worlds, and also can run in isolated mode.
//
// But for now, there's only one chunk.
service ChunkService {
    // New RPC to return CPU/memory/network load of this chunk server? Also need
    // connectivity info. (IMO it makes sense to make FE manage list of chunk
    // servers, and each chunk server don't know about list other than
    // neighbors)
    //
    // (FE will decide whether to spawn new chunk servers, migrate chunks etc).
    // Or maybe just dump them to datastore (because bigtable is expensive to
    // maintain), and make FE query them. With this approach, we get history for
    // free. (we can also do dashboards w/ bigquery)

    // Should be renamed.
    // Get status of chunks.
    rpc Status(StatusQ) returns (StatusS);

    rpc Benchmark(BenchmarkQ) returns (BenchmarkS);

    rpc ModifyChunk(ModifyChunkQ) returns (ModifyChunkS);

    rpc SpawnChunk(SpawnChunkQ) returns (SpawnChunkS);

    // Move some chunks to other chunk server?
    // rpc MigrateChunk()
}

// Spawn a chunk in this chunk server. This request itself is very lightweight.
// (although server might slowdown afterwards).
message SpawnChunkQ {
    // Opaque unique id of this chunk. Caller will make sure this is actually
    // unique across all biospheres.
    string chunk_id = 1;

    // Description of a neighbor chunk.
    // (dx, dy) != (0, 0) must hold.
    message ChunkNeighbor {
        // Neighbor's chunk id.
        string chunk_id = 1;

        // If true, neighbor is on the same node.
        bool internal = 2;

        // Chunk server IP address where neighbor is running.
        // Disregarded when internal is true.
        string address = 3;

        // Relative position of this neighbor to the newly created chunk.
        // must be relatively small (|dx| <= 1) for correct operation.
        int32 dx = 4;

        // Relative position of this neighbor to the newly created chunk.
        // must be relatively small (|dx| <= 1) for correct operation.
        int32 dy = 5;
    }

    // 8-Neighbors. When not specified, it is assumed that location is empty
    // (regardless of dx, dy) and there is wall between neighbor and this (when
    // neighbor is a 4-neighbor).
    repeated ChunkNeighbor neighbors = 2;
}

message SpawnChunkS {
}

message StatusQ {
}

message StatusS {
    ChunkSnapshot snapshot = 1;
    uint64 snapshot_timestamp = 2;
}


message BenchmarkQ {
}

message BenchmarkS {
    // Human-readable, multi line report of the benchmark.
    string report = 1;
}


message ModifyChunkQ {
    enum Speed {
        // Do not step.
        ZERO = 0;

        // Operate at close to realtime (best effort).
        NORMAL = 1;

        // Allocate as many cores as possible to the chunk to speed up thing,
        // even though that's inefficient.
        FASTEST = 2;
    }

    // Set chunk's speed.
    Speed target_speed = 1;

    // Target timestamp to step to. Specify max uint64 to represent "infinite".
    // (all servers' behaviors are undefined after passing that max).
    //
    // Invariant: timestamp <= target_timestamp.
    //
    // TODO: what to do if timestamp of the past is specified?
    uint64 target_timestamp = 2;
}

message ModifyChunkS {
    // Current timestamp.
    // It's guaranteed that
    // * when stop: chunk will stay at timestamp until further requests.
    // * when !stop; actual timestamp >= timestamp
    uint64 timestamp = 1;
}


// Snapshot of a chunk at given timestamp.
// This contains enough and just enough information for reconstructing it on
// memory.
// Do not include optimization structures in this, since we don't want to break
// compatibility every time we optimize implemenetation.
//
// Serialization acts as validation of internal state.
//
// Coordinates are stored by chunk-local coordinates.
message ChunkSnapshot {
    // Should be negative for normal gravity.
    int32 gravity_z = 1;

    repeated Cell cells = 2;
    repeated Grain grains = 4;

    reserved 3;
}

// Next Id: 4
message Grain {
    uint64 id = 3;

    CkPosition pos = 1;
    enum Kind {
        UNKNOWN = 0;
        WATER = 1;
        SOIL = 2;
    }
    Kind kind = 2;
}

// Self-replicating blackbox. It has fuzzy sphere-like shape.
// Cell doesn't have rotation or angular velocity.
//
// Mass is derived property.
message Cell {
    // Location of the center of the cell.
    CkPosition pos = 1;

    // Chemical compounds contained in the cell.
    // This must be treated like MultiSet ParticleType.
    message ParticleCount {
        ParticleType type = 1;
        // Must be > 0.
        int32 count = 2;
    }
    repeated ParticleCount particles = 2;

    // Division cycle.
    // N: neutral
    // D: dividing
    // N -> D is triggered by presence of:
    // D -> N: happens automatically as division_count increases.
    message Cycle {
        bool is_dividing = 1;
        // Only present when is_dividing.
        int32 division_count = 2;
    }
    Cycle cycle = 3;
}


message ParticleType {
    // e.g. "abzf"
    string composition = 1;
}

// Unit: 0.1mm
// which means, each can be about [-200km, 200km].
message CkPosition {
    int32 x = 1;
    int32 y = 2;
    int32 z = 3;
}
